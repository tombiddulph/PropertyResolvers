using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace PropertyResolvers.Generators;

[Generator]
public class PropertyResolverGenerator : IIncrementalGenerator
{
   private const string AttributeFullName = "PropertyResolvers.Attributes.GeneratePropertyResolverAttribute";
//
//     private const string AttributeSourceCode = """
//                                                // <auto-generated/>
//                                                #nullable enable
//
//                                                namespace PropertyResolvers;
//
//                                                [System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple = true)]
//                                                public class GeneratePropertyResolverAttribute : System.Attribute
//                                                {
//                                                    public string PropertyName { get; }
//                                                    public System.Type PropertyType { get; set; } = typeof(string);
//                                                    public string[]? IncludeNamespaces { get; set; }
//                                                    public string[]? ExcludeNamespaces { get; set; }
//                                                    public string? ResolverClassName { get; set; }
//                                                    
//                                                    public GeneratePropertyResolverAttribute(string propertyName)
//                                                    {
//                                                        PropertyName = propertyName;
//                                                    }
//                                                }
//
//                                                """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // // Register the attribute source
        // context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
        //     "GeneratePropertyResolverAttribute.g.cs",
        //     SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Get configs and root namespace from compilation
        var compilationData = context.CompilationProvider
            .Select((compilation, _) => (
                Configs: GetResolverConfigs(compilation),
                RootNamespace: GetRootNamespace(compilation)
            ));

        // Get all named types in the compilation
        var allTypes = context.CompilationProvider
            .SelectMany((compilation, _) => GetAllNamedTypes(compilation));

        // Combine configs with all types
        var combined = compilationData.Combine(allTypes.Collect());

        // Generate the resolvers
        context.RegisterSourceOutput(combined, (ctx, source) =>
        {
            var ((configs, rootNamespace), types) = source;
            GenerateResolvers(ctx, configs, types, rootNamespace);
        });
    }

    private static string GetRootNamespace(Compilation compilation)
    {
        // Try to get from assembly name first
        var assemblyName = compilation.AssemblyName;
        if (!string.IsNullOrEmpty(assemblyName))
            return assemblyName;

        // Fallback: try to infer from the most common root namespace of types
        var namespaces = compilation.Assembly
            .GlobalNamespace
            .GetNamespaceMembers()
            .Where(ns => !ns.IsGlobalNamespace && 
                         !ns.Name.StartsWith("System") && 
                         !ns.Name.StartsWith("Microsoft"))
            .Select(ns => ns.Name)
            .ToList();

        if (namespaces.Count > 0)
            return namespaces.First();

        // Ultimate fallback
        return "Generated";
    }

    private static ImmutableArray<ResolverConfig> GetResolverConfigs(Compilation compilation)
    {
        var configs = new List<ResolverConfig>();
        
        foreach (var attribute in compilation.Assembly.GetAttributes())
        {
            if (attribute.AttributeClass?.ToDisplayString() != AttributeFullName)
                continue;

            var propertyName = attribute.ConstructorArguments[0].Value as string;
            if (string.IsNullOrEmpty(propertyName))
                continue;

            var config = new ResolverConfig
            {
                PropertyName = propertyName!
            };

            foreach (var namedArg in attribute.NamedArguments)
            {
                switch (namedArg.Key)
                {
                    case "IncludeNamespaces":
                        config.IncludeNamespaces = namedArg.Value.Values
                            .Select(v => v.Value as string)
                            .Where(v => v != null)
                            .Cast<string>()
                            .ToArray();
                        break;
                    
                    case "ExcludeNamespaces":
                        config.ExcludeNamespaces = namedArg.Value.Values
                            .Select(v => v.Value as string)
                            .Where(v => v != null)
                            .Cast<string>()
                            .ToArray();
                        break;
                    
                    case "ResolverClassName":
                        config.ResolverClassName = namedArg.Value.Value as string;
                        break;
                }
            }

            configs.Add(config);
        }

        return configs.ToImmutableArray();
    }

    private static IEnumerable<TypeInfo> GetAllNamedTypes(Compilation compilation)
    {
        var types = new List<TypeInfo>();
        CollectTypes(compilation.GlobalNamespace, types);
        return types;
    }

    private static void CollectTypes(INamespaceSymbol ns, List<TypeInfo> types)
    {
        foreach (var type in ns.GetTypeMembers())
        {
            // Skip generic types - they cannot be pattern-matched in switch expressions
            if (type.IsGenericType)
                continue;

            if (type.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var properties = type.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null)
                    .Select(p => new PropertyInfo(p.Name, p.Type.ToDisplayString()))
                    .ToImmutableArray();

                if (properties.Length > 0)
                {
                    types.Add(new TypeInfo(
                        type.ToDisplayString(),
                        type.ContainingNamespace?.ToDisplayString() ?? "",
                        properties));
                }
            }

            // Recurse into nested types
            foreach (var nested in type.GetTypeMembers())
            {
                CollectNestedTypes(nested, types);
            }
        }

        foreach (var childNs in ns.GetNamespaceMembers())
        {
            CollectTypes(childNs, types);
        }
    }

    private static void CollectNestedTypes(INamedTypeSymbol type, List<TypeInfo> types)
    {
        // Skip generic types - they cannot be pattern-matched in switch expressions
        if (type.IsGenericType)
            return;

        if (type.TypeKind is TypeKind.Class or TypeKind.Struct)
        {
            var properties = type.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null)
                .Select(p => new PropertyInfo(p.Name, p.Type.ToDisplayString()))
                .ToImmutableArray();

            if (properties.Length > 0)
            {
                types.Add(new TypeInfo(
                    type.ToDisplayString(),
                    type.ContainingNamespace?.ToDisplayString() ?? "",
                    properties));
            }
        }

        foreach (var nested in type.GetTypeMembers())
        {
            CollectNestedTypes(nested, types);
        }
    }

    private static void GenerateResolvers(
        SourceProductionContext context,
        ImmutableArray<ResolverConfig> configs,
        ImmutableArray<TypeInfo> allTypes,
        string rootNamespace)
    {
        if (configs.Length == 0)
            return;

        var generatedNamespace = $"{rootNamespace}";

        // Deduplicate configs by property name (take first occurrence only)
        // The analyzer will report diagnostics for duplicates
        var deduplicatedConfigs = configs
            .GroupBy(c => c.PropertyName, System.StringComparer.OrdinalIgnoreCase)
            .Select(g => g.First())
            .ToList();

        // Group by resolver class name
        var byClassName = deduplicatedConfigs
            .GroupBy(c => c.ResolverClassName ?? "PropertyResolversTest")
            .ToList();

        foreach (var group in byClassName)
        {
            var className = group.Key;
            var methods = new StringBuilder();

            foreach (var config in group)
            {
                // var matchingTypes = allTypes
                //     .Where(t => ShouldIncludeType(t, config))
                //     .Where(t => t.Properties.Any(p =>
                //         p.Name.Equals(config.PropertyName, StringComparison.OrdinalIgnoreCase)))
                //     .ToList();
                
                var matches = allTypes
                    .Where(t => ShouldIncludeType(t, config))
                    .SelectMany(t => t.Properties
                        .Where(p => p.Name.Equals(config.PropertyName, StringComparison.OrdinalIgnoreCase))
                        .Select(p => (TypeFullName: t.FullName, PropertyName: p.Name)))
                    .ToList();

                if (matches.Count == 0)
                    continue;

                const string returnType = "string?";
                var methodName = $"Get{config.PropertyName}";

                methods.AppendLine($"    public static {returnType} {methodName}(object? obj) => obj switch");
                methods.AppendLine("    {");
                
                
                foreach (var (typeName, propertyName) in matches)
                {
                    methods.AppendLine($"        global::{typeName} x => x.{propertyName}.ToString(),");
                }

                methods.AppendLine("        _ => null");
                methods.AppendLine("    };");
                methods.AppendLine();
            }

            if (methods.Length == 0)
                continue;

            var code = $$"""
                         // <auto-generated/>
                         #nullable enable

                         namespace {{generatedNamespace}};

                         public static class {{className}}
                         {
                         {{methods}}}

                         """;

            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private static bool ShouldIncludeType(TypeInfo type, ResolverConfig config)
    {
        var ns = type.Namespace;

        // If includes specified, namespace must match one
        if (config.IncludeNamespaces is { Length: > 0 })
        {
            if (!config.IncludeNamespaces.Any(inc => ns.StartsWith(inc)))
                return false;
        }

        // If excludes specified, namespace must not match any
        if (config.ExcludeNamespaces is { Length: > 0 })
        {
            if (config.ExcludeNamespaces.Any(exc => ns.StartsWith(exc)))
                return false;
        }

        return true;
    }

    private class ResolverConfig
    {
        public string PropertyName { get; set; } = "";
        public string[]? IncludeNamespaces { get; set; }
        public string[]? ExcludeNamespaces { get; set; }

        public string? ResolverClassName
        {
            get => $"{PropertyName}Resolver";
            set;
        }
    }

    private record struct PropertyInfo(string Name, string Type);
    
    private record struct TypeInfo(string FullName, string Namespace, ImmutableArray<PropertyInfo> Properties);
}
